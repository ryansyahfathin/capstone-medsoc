# -*- coding: utf-8 -*-
"""Capstone Medsoc

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DRh162CiMJM1OV42q8hHhHgQ2waz14Qh
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""# Load Data"""

import gdown

# Link unduhan langsung
file_id = '1E4W1RvNGgyawc6I4TxQk76n289FX9kCK'
url = f'https://drive.google.com/uc?id={file_id}'


gdown.download(url, 'dataset social media.xlsx', quiet=False)

df = pd.read_excel('dataset social media.xlsx', sheet_name='Working File')
df.head()

df.describe()

df.isnull().sum()

df.nunique()

df['Audience Gender'].unique()

#memisahkan kolom post timestamp
df['Time'] = df['Post Timestamp'].dt.time
df['Date'] = df['Post Timestamp'].dt.date
df['Day'] = df['Post Timestamp'].dt.day
df['Month'] = df['Post Timestamp'].dt.month
df['Year'] = df['Post Timestamp'].dt.year

print(df[['Time', 'Date', 'Day', 'Month', 'Year']])

Reorder = ['Time', 'Date', 'Day', 'Month', 'Year', 'Weekday Type', 'Time Periods', 'Platform','Post Type', 'Post Content', 'Likes', 'Comments', 'Shares', 'Impressions', 'Reach', 'Engagement Rate', 'Audience Age', 'Age Group', 'Audience Gender', 'Audience Location', 'Audience Continent', 'Audience Interests', 'Sentiment'] # Removed several columns from the Reorder list
df = df[Reorder] # Reorder the DataFrame columns
df.head()

dfs = df.copy()

dfs['Time'] = dfs['Time'].apply(lambda x: x.replace(microsecond=0))

dfs['Date'] = pd.to_datetime(dfs['Date'], errors='coerce')
dfs['Time'] = dfs['Time'].apply(lambda x: x.strftime('%H:%M:%S'))

dfs['Hour'] = dfs['Time'].str.split(':').str[0].astype(int)

# Tampilkan beberapa baris untuk memastikan kolom 'Hour' berhasil ditambahkan
print(dfs[['Time', 'Hour']].head())

dfs

dfs.dtypes

"""alasan melakukan drop pada kolom campaign ID dan influencer ID adalah karena kolom tersebut memiliki banyak missing value dan juga tidak dibutuhkan untuk analisis lebih lanjut. kolom post content dihapus karena tujuannya fokus ke waktu postingan saja. melakukan drop pada kolom time karena isinya sama seperti kolom post timestamp"""

dfs.duplicated().sum()

dfs.isnull().sum()

df_copy = dfs.copy()

# Membuat fitur Total Engagement
df_copy['Total Engagement'] = df_copy[['Likes', 'Comments', 'Shares']].sum(axis=1)

"""alasan membuat kolom baru dengan nama total engagement yaitu penjumlahan antara kolom likes, comments, dan shares adalah agar mudah untuk dianalisis dan digunakan oleh model kemudian dengan membuat fitur baru tersebut dapat langsung menunjukkan seberapa besar sebuah postingan menghasilkan interaksi. namun, tidak mengikutsertakan kolom reach dan impressions karena kolom tersebut tidak menunjukkan interaksi aktif tapi hanya eksposur jadi tidak dihitung sebagai engagement"""

# Set option to display all columns
pd.set_option('display.max_columns', None)

df_copy

"""#EDA 1 (Numerical)"""

numerical_cols = df_copy.select_dtypes(include=[np.number]).columns
df_copy[numerical_cols].hist(figsize=(15, 10), bins=20, edgecolor='black')
plt.suptitle("Distribusi Fitur Numerik", fontsize=16)
plt.tight_layout()
plt.show()

#Korelasi antar kolom numerik
plt.figure(figsize=(12, 8))
correlation = df_copy[numerical_cols].corr()
sns.heatmap(correlation, annot=True, cmap="coolwarm", fmt=".2f", square=True)
plt.title("Matriks Korelasi")
plt.show()

selected_categorical_cols = [
    'Platform', 'Post Type', 'Age Group',
    'Audience Gender', 'Audience Continent', 'Sentiment'
]

# Tampilkan jumlah per kategori untuk masing-masing kolom
for col in selected_categorical_cols:
    print(f"\n=== Jumlah per kategori untuk '{col}' ===")
    print(df_copy[col].value_counts(dropna=False))

# --- Posting dengan engagement tertinggi (misal Likes + Comments + Shares)
if set(['Likes', 'Comments', 'Shares']).issubset(df_copy.columns):
    df_copy['Total_Engagement'] = df_copy['Likes'] + df_copy['Comments'] + df_copy['Shares']
    top_posts = df_copy.sort_values('Total_Engagement', ascending=False).head(10)
    print("Top 10 postingan dengan engagement tertinggi:")
    display(top_posts[['Total_Engagement'] + [col for col in df_copy.columns if col not in numerical_cols]])

#boxplot
for col in numerical_cols:
    plt.figure(figsize=(6, 4))
    df_copy.boxplot(column=[col])
    plt.title(f'Box Plot for {col}')
    plt.show()

import pandas as pd
from ydata_profiling import ProfileReport

# Buat laporan Pandas Profiling
profile = ProfileReport(df_copy, explorative=True)

# Tampilkan laporan di notebook
profile.to_notebook_iframe()

df_cp = df_copy.copy()

# plot untuk mengecek skewness

for col in numerical_cols:
    plt.figure(figsize=(8, 6))
    sns.histplot(df_cp[col], kde=True)  # Use histplot with kde for better skewness visualization
    plt.title(f'Distribution Plot for {col}')
    plt.xlabel(col)
    plt.ylabel('Frequency')
    plt.show()

"""#Pre-processing 2"""

# Boxplot untuk memvisualisasikan skewness
plt.figure(figsize=(30, 15))
sns.boxplot(data=df_copy[numerical_cols], orient='h')
plt.title('Boxplot of Numerical Variables')
plt.show()

#cek outlier
for col in numerical_cols:
  Q1 = df_cp[col].quantile(0.25)
  Q3 = df_cp[col].quantile(0.75)
  IQR = Q3 - Q1
  lower_bound = Q1 - 1.5 * IQR
  upper_bound = Q3 + 1.5 * IQR
  #menampilkan number of outliers
  outliers = df_cp[(df_cp[col] < lower_bound) | (df_cp[col] > upper_bound)]
  num_outliers = len(outliers)
  print(f"Number of outliers in {col}: {num_outliers}")


  percentage_outliers = (num_outliers / len(df_cp)) * 100
  print(f"Percentage of outliers in {col}: {percentage_outliers:.2f}%")
  print("\n")

# Hitung Q1, Q3, dan IQR untuk kolom 'Engagement Rate'
Q1 = df_cp['Engagement Rate'].quantile(0.25)
Q3 = df_cp['Engagement Rate'].quantile(0.75)
IQR = Q3 - Q1

# Hitung skewness untuk kolom 'Engagement Rate'
skewness = df_cp['Engagement Rate'].skew()
print(f"Q1: {Q1}")
print(f"Q3: {Q3}")
print(f"IQR: {IQR}")
print(f"Skewness: {skewness}")

# Cek jenis skewness
if skewness > 0:
    print("Distribusi data: Positif (miring ke kanan)")
elif skewness < 0:
    print("Distribusi data: Negatif (miring ke kiri)")
else:
    print("Distribusi data: Simetris")

# Hitung Q1, Q3, dan IQR untuk kolom 'Impressions'
Q1 = df_cp['Impressions'].quantile(0.25)
Q3 = df_cp['Impressions'].quantile(0.75)
IQR = Q3 - Q1

# Hitung skewness untuk kolom 'Impressions'
skewness = df_cp['Impressions'].skew()
print(f"Q1: {Q1}")
print(f"Q3: {Q3}")
print(f"IQR: {IQR}")
print(f"Skewness: {skewness}")

# Cek jenis skewness
if skewness > 0:
    print("Distribusi data: Positif (miring ke kanan)")
elif skewness < 0:
    print("Distribusi data: Negatif (miring ke kiri)")
else:
    print("Distribusi data: Simetris")

# Hitung Q1, Q3, dan IQR untuk kolom 'Reach'
Q1 = df_cp['Reach'].quantile(0.25)
Q3 = df_cp['Reach'].quantile(0.75)
IQR = Q3 - Q1

# Hitung skewness untuk kolom 'Reach'
skewness = df_cp['Reach'].skew()
print(f"Q1: {Q1}")
print(f"Q3: {Q3}")
print(f"IQR: {IQR}")
print(f"Skewness: {skewness}")

# Cek jenis skewness
if skewness > 0:
    print("Distribusi data: Positif (miring ke kanan)")
elif skewness < 0:
    print("Distribusi data: Negatif (miring ke kiri)")
else:
    print("Distribusi data: Simetris")

""" hanya melakukan penanganan skewness pada kolom engagement rate saja karena nilai skewness untuk kolom reach dan impressions masih dalam rentang -0.5 dan 0.5. biasa dianggap mendekati simetris. oleh karena itu, tidak diperlukan penanganan"""

from scipy import stats
# Box-Cox transformation (hanya untuk data positif)
df_cp['Engagement Rate'], _ = stats.boxcox(df_cp['Engagement Rate'])

# Cek skewness setelah Box-Cox transformation
plt.figure(figsize=(8, 6))
sns.histplot(df_cp['Engagement Rate'], kde=True)
plt.title(f'Skewness Plot after Box-Cox Transformation for Engagement Rate')
plt.xlabel('Engagement Rate (Box-Cox Transformed)')
plt.ylabel('Frequency')
plt.show()

Q1 = df_cp['Engagement Rate'].quantile(0.25)
Q3 = df_cp['Engagement Rate'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outliers = df_cp[(df_cp['Engagement Rate'] < lower_bound) | (df_cp['Engagement Rate'] > upper_bound)]
num_outliers = len(outliers)
percentage_outliers = (num_outliers / len(df_cp)) * 100

print(f"Number of outliers in Engagement Rate after Box-Cox transformation: {num_outliers}")
print(f"Percentage of outliers in Engagement Rate after Box-Cox transformation: {percentage_outliers:.2f}%")

# Boxplot setelah transformasi Box-Cox
plt.figure(figsize=(6, 4))
df_cp.boxplot(column=['Engagement Rate'])
plt.title(f'Box Plot for Engagement Rate after Box-Cox Transformation')
plt.show()

"""menggunakan box cox transformation karena jika menggunakan log transformation skewnessnya tidak mengalami perubahan yang signifikan. box cox transformation dipilih karena mampu dapat menyesuaikan parameter untuk mencari cara terbaik untuk membuat data lebih normal"""

# Hitung Q1, Q3, dan IQR untuk kolom 'Engagement Rate'
Q1 = df_cp['Engagement Rate'].quantile(0.25)
Q3 = df_cp['Engagement Rate'].quantile(0.75)
IQR = Q3 - Q1

# Hitung skewness untuk kolom 'Engagement Rate'
skewness = df_cp['Engagement Rate'].skew()
print(f"Q1: {Q1}")
print(f"Q3: {Q3}")
print(f"IQR: {IQR}")
print(f"Skewness: {skewness}")

# Cek jenis skewness
if skewness > 0:
    print("Distribusi data: Positif (miring ke kanan)")
elif skewness < 0:
    print("Distribusi data: Negatif (miring ke kiri)")
else:
    print("Distribusi data: Simetris")

"""walaupun hasil dari boxcox menunjukkan data sudan hampir simetris namun outliernya masih ada dan terhitung bahwa outliernya extreme dan kemungkinan dapat mempengaruhi klustering. oleh karena itu, dilakukan winsorization untuk menangani outliernya"""

#winsorization (Capping) untuk mengatasi outlier

# Tentukan batas atas dan bawah berdasarkan IQR
Q1 = df_cp['Engagement Rate'].quantile(0.25)
Q3 = df_cp['Engagement Rate'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# capping untuk mengganti outlier dengan batas atas atau bawah
df_cp['Engagement Rate'] = df_cp['Engagement Rate'].apply(lambda x: min(x, upper_bound) if x > upper_bound else (max(x, lower_bound) if x < lower_bound else x))

# Boxplot setelah winsorization
plt.figure(figsize=(6, 4))
df_cp.boxplot(column=['Engagement Rate'])
plt.title(f'Box Plot for Engagement Rate after winsorization')
plt.show()

"""#EDA 2 (Kategorikal)"""

cat_col = ['Weekday Type', 'Time Periods', 'Platform', 'Post Type', 'Post Content', 'Audience Age', 'Age Group', 'Audience Gender', 'Audience Location', 'Audience Continent', 'Audience Interests', 'Sentiment']

#univariate variabel kategorikal
#for col in cat_col:
#   plt.figure(figsize=(8, 4))
#    sns.countplot(data=df_cp, x=col)
#   plt.title(f'Distribution of {col}')
#   plt.xticks(rotation=45)
#    plt.show()

cross_tab = pd.crosstab(df_copy['Post Type'], df_copy['Platform'])
print(cross_tab)

plt.figure(figsize=(10, 6))

sns.countplot(data=df_copy, x='Age Group', hue='Platform')

plt.title('Distribusi Kelompok Usia Audiens Berdasarkan Platform')
plt.xlabel('Kelompok Usia')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.tight_layout()

plt.show()

plt.figure(figsize=(10, 6))

sns.barplot(data=df_copy, y='Engagement Rate', x= 'Sentiment')

plt.title('Distribusi Kelompok sentiment Berdasarkan Engagement rate')
plt.xlabel('Kelompok sentiment')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.tight_layout()

plt.show()

# Plotting the line plot
plt.figure(figsize=(12,8))
sns.lineplot(data=df_copy, x='Year', y='Engagement Rate')

# Adding labels and title
plt.title('Engagement Rate by Year')
plt.xlabel('Year')
plt.ylabel('Engagement Rate')

# Show the plot
plt.show()

#bivariate numerik vs income
#for col in cat_col:
#   plt.figure(figsize=(8, 4))
#   sns.countplot(data=df_copy, x=col, hue='Engagement Rate')
#   plt.title(f'{col} vs Engagement Rate')
#   plt.xticks(rotation=45)
#   plt.show()

"""#preprocessing 3"""

df1_cp=df_copy.copy()

features = [
    'Time Periods',
    'Weekday Type',
    'Engagement Rate',
    'Total Engagement',
    'Platform',
    'Post Type',
    'Sentiment',
    'Age Group',
    'Audience Gender',
    'Hour'
]

from sklearn.preprocessing import LabelEncoder
# Copy agar tidak mengubah df asli
df_encoded = df1_cp[features].copy()

# Label encode kolom ordinal
le = LabelEncoder()
for col in ['Weekday Type', 'Time Periods', 'Sentiment', 'Age Group', 'Audience Gender']:
    df_encoded[col] = le.fit_transform(df_encoded[col])

# One-hot encode kolom nominal
df_encoded = pd.get_dummies(df_encoded, columns=['Platform', 'Post Type'], drop_first=True)

df_encoded

df_encoded_num = df_encoded.select_dtypes(include=['float64', 'int64'])

# Hitung korelasi antar kolom numerik
correlation_matrix = df_encoded_num.corr()

# Membuat Heatmap untuk Korelasi
plt.figure(figsize=(14, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Heatmap of Feature Correlations')
plt.tight_layout()
plt.show()

"""# **Modeling**"""

df_cp2 = df_encoded.copy()

df_cp2.head()

"""## Gradient Boost"""

from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.ensemble import GradientBoostingRegressor

# Misalkan X dan y adalah data fitur dan target Anda
# Memisahkan fitur dan target
X = df_cp2.drop(['Total Engagement'], axis=1)  # Fitur (tanpa target)
y = df_cp2['Total Engagement']  # Target (Total Engagement)

# Membagi data menjadi set pelatihan dan set pengujian (80% training, 20% testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Membuat model Gradient Boosting
gb_model = GradientBoostingRegressor(n_estimators=1000, learning_rate=0.05, max_depth=6, random_state=42)

# Melatih model
gb_model.fit(X_train, y_train)

# Prediksi pada data test
y_pred_gb = gb_model.predict(X_test)

# Evaluasi Model
mae_gb = mean_absolute_error(y_test, y_pred_gb)
mse_gb = mean_squared_error(y_test, y_pred_gb)

print(f"Gradient Boosting - Mean Absolute Error (MAE): {mae_gb}")
print(f"Gradient Boosting - Mean Squared Error (MSE): {mse_gb}")

# 1. Input dari pengguna
platform_input = input("Masukkan platform (Instagram, Facebook, Twitter, LinkedIn): ")
post_type_input = input("Masukkan jenis video yang akan diposting (Video, Link, Image): ")
gender_input = input("Masukkan target gender (Male, Female, Other): ")
age_group_input = input("Masukkan kelompok usia yang ditargetkan (Senior Adults, Mature Adults, Adolescent Adults): ")

# 2. Membuat dataframe berdasarkan input pengguna
data_input = {
    'Platform': [platform_input],
    'Post Type': [post_type_input],
    'Audience Gender': [gender_input],
    'Age Group': [age_group_input]
}

# Convert menjadi dataframe
input_df = pd.DataFrame(data_input)

# 3. Melakukan One-Hot Encoding pada fitur kategorikal
input_df_encoded = pd.get_dummies(input_df, columns=['Platform', 'Post Type', 'Audience Gender', 'Age Group'])

# 4. Mengambil kolom yang ada pada df_cp2 untuk memastikannya sesuai dengan yang digunakan pada pelatihan model
# Membaca kolom dari df_cp2 setelah preprocessing
input_df_encoded = input_df_encoded.reindex(columns=X_train.columns, fill_value=0)

# 5. Menggunakan model yang sudah dilatih untuk memprediksi engagement
predicted_engagement = gb_model.predict(input_df_encoded)

# 6. Menambahkan prediksi engagement ke dalam dataframe
input_df_encoded['Predicted Engagement'] = predicted_engagement

# 7. Menentukan output berdasarkan hasil prediksi
output = {
    'Predicted Engagement': predicted_engagement[0],  # Ambil hasil prediksi pertama
    'Weekday Type': 'Weekday',  # Atau bisa disesuaikan dengan prediksi lainnya
    'Hour': 12  # Ganti dengan jam terbaik berdasarkan hasil prediksi model atau data lainnya
}

output_df = pd.DataFrame([output])

print("\n-------------------------------------------")
print("       Hasil Prediksi Waktu Posting       ")
print("-------------------------------------------")
print(f"Platform         : {platform_input}")
print(f"Jenis Video      : {post_type_input}")
print(f"Target Gender    : {gender_input}")
print(f"Kelompok Usia    : {age_group_input}")
print("-------------------------------------------")
print(f"Predicted Engagement   : {output['Predicted Engagement']:.2f}")
print(f"Weekday Type          : {output['Weekday Type']}")
print(f"Jam Posting Terbaik   : {output['Hour']}.00 WIB")  # Format jam
print("-------------------------------------------")
